#!/usr/bin/env ruby

def parse_unicodedata(name)
    first = nil
    File.foreach(name) do |line|
        rec = line.chomp.split(';', -1)
        if rec[1].end_with?('First>') then
            first = rec
        elsif rec[1].end_with?('Last>') then
            (first[0].to_i(16)).upto(rec[0].to_i(16)) do |cp|
                yield cp, first
            end
        else
            yield rec[0].to_i(16), rec
        end
    end
end

def parse_unicodefile(name)
    File.foreach(name) do |line|
        line.sub!(/\s*#.*/, '')
        line.strip!
        next if line.empty?
        rec = line.split(';', -1).map {|s| s.strip}
        if rec[0] =~ /^([[:xdigit:]]+)\.\.([[:xdigit:]]+)/; then
            s = $1.to_i(16)
            e = $2.to_i(16)
            s.upto(e) do |cp|
                yield cp, rec
            end
        else
            yield rec[0].to_i(16), rec
        end
    end
end

def print_ranges(fp, ranges)
    cps = ranges.keys.sort
    return if cps.empty?
    first = nil
    last = nil
    cps.each do |cp|
        if first.nil? then
            first = cp
            last = cp
        elsif last + 1 == cp then
            last = cp
        else
            fp.puts "    { 0x%04X, 0x%04X }," % [ first, last ]
            first = cp
            last = cp
        end
    end
    fp.puts "    { 0x%04X, 0x%04X }" % [ first, last ]
end

def print_map(fp, map)
    m = map.sort {|a, b| a[0] <=> b[0]}
    m.each do |r|
        fp.puts "    { 0x%04X, 0x%04X }," % r
    end
end

alpha = {}
upper = {}
lower = {}
space = {}
cntrl = {}
print = {}
punct = {}
to_upper = []
to_lower = []

parse_unicodedata("UnicodeData.txt") do |cp, rec|
    if rec[2].start_with?('L') || rec[2] == 'Nl' then
        alpha[cp] = true
    end
    if rec[2] == 'Nd' && cp > 0x39 then
        alpha[cp] = true
    end
    if rec[2] == 'Ll' || rec[2] == 'Lt' then
        lower[cp] = true
    end
    if rec[2] == 'Cc' then
        cntrl[cp] = true
    end
    if rec[2] != 'Cc' && rec[2] != 'Cs' then
        print[cp] = true
    end
    if rec[2] == 'Lu' || rec[2] == 'Lt' then
        upper[cp] = true
    end
    if rec[2] =~ /^[PS]|^M[en]$|^C[fo]$|^No$/ then
        punct[cp] = true
    end
    if rec[5].start_with?('<noBreak>') then
        punct[cp] = true
    end
    if rec[12] != '' then
        to_upper << [ cp, rec[12].to_i(16) ]
    end
    if rec[13] != '' then
        to_lower << [ cp, rec[13].to_i(16) ]
    end
end

parse_unicodefile("PropList.txt") do |cp, rec|
    if rec[1] == 'Other_Alphabetic' then
        alpha[cp] = true
        punct.delete(cp)
    elsif rec[1] == 'Other_Uppercase' then
        upper[cp] = true
        punct.delete(cp)
    elsif rec[1] == 'Other_Lowercase' then
        lower[cp] = true
        punct.delete(cp)
    elsif rec[1] == 'White_Space' && !punct[cp] then
        space[cp] = true
    end
end

# Special cases
cntrl[0x2028] = true
cntrl[0x2029] = true
print.delete(0x2028)
print.delete(0x2029)

File.open("walpha.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* alpha is defined as general category L[a-z] or N[dl], or the"
    fp.puts "   Other_Alphabetic property */"
    fp.puts "static struct chr_range const alpha[] = {"
    print_ranges(fp, alpha);
    fp.puts "};"
end

File.open("wupper.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* upper is defined as general category Lu or Lt, or the"
    fp.puts "   Other_Uppercase property */"
    fp.puts "static struct chr_range const upper[] = {"
    print_ranges(fp, upper);
    fp.puts "};"
end

File.open("wlower.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* lower is defined as general category Ll or Lt, or the"
    fp.puts "   Other_Lowercase property */"
    fp.puts "static struct chr_range const lower[] = {"
    print_ranges(fp, lower);
    fp.puts "};"
end

File.open("wspace.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* space is defined as the White_Space property */"
    fp.puts "static struct chr_range const space[] = {"
    print_ranges(fp, space);
    fp.puts "};"
end

File.open("wcntrl.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* cntrl is defined as general category Cc */"
    fp.puts "static struct chr_range const cntrl[] = {"
    print_ranges(fp, cntrl);
    fp.puts "};"
end

File.open("wprint.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* print is defined as all defined code points with general category other"
    fp.puts "   than Cc or Cs */"
    fp.puts "static struct chr_range const print[] = {"
    print_ranges(fp, print);
    fp.puts "};"
end

File.open("wpunct.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* punct is defined as general category [PS][a-z], but not having the properties"
    fp.puts "   Other_Alphabetic, Other_Uppercase, Other_Lowercase or White_Space */"
    fp.puts "static struct chr_range const punct[] = {"
    print_ranges(fp, punct);
    fp.puts "};"
end

File.open("wupmap.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* map from lower to uppercase */"
    fp.puts "static struct chr_map const to_upper[] = {"
    print_map(fp, to_upper);
    fp.puts "};"
end

File.open("wlowmap.h", "w") do |fp|
    fp.puts "/* data table generated by chrdata.rb */"
    fp.puts "/* map from upper to lowercase */"
    fp.puts "static struct chr_map const to_lower[] = {"
    print_map(fp, to_lower);
    fp.puts "};"
end
